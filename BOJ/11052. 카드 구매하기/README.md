---
문제번호: 11052
문제이름: '카드 구매하기'
주소: 'https://www.acmicpc.net/problem/11052'
분류: ['다이나믹 프로그래밍']
---

# 풀이

현재 인덱스의 값과 현재 인덱스를 만들 수 있는 인덱스들의 원소의 합을 비교하여 풀었다. 예컨대 주어진 케이스가 `n = 5, p = [10, 9, 8, 7, 6]` 이라고 하자.
뽑을 수 있는 최대 값들을 담은 배열을 `dp`라 선언하고 0번 인덱스, 즉 첫 번째 원소에 0을 할당하고 1번 인덱스인 두 번째 원소에 `p[0]`를 할당한다. 0개 뽑을 수 있는 금액은 0이고 1개를 뽑을 때 최대 금액은 `p[0]`이기 때문.

할당 가능한 인덱스를 `i`가 5일 때 이를 만들 수 있는 방법은 `1 + 4`, `2 + 3`, `3 + 2`, `4 + 1`이 된다. `i`가 0인 경우는 자기자신이므로 `i`의 절반을 넘어서면 중복이 되므로 절반까지만 구할 수 있도록 `i`의 절반을 구한다. 이후 `i` 인덱스의 원소 값과 `i`를 만들 수 있는 인덱스 원소들의 합을 비교하여 더 큰 값을 구한다.

```js
const [n, nums] = require('fs').readFileSync('/dev/stdin').toString().trim().split('\n');
const p = nums.split(' ').map(Number);

const dp = [0, p[0]];
for (let i = 2; i <= n; i += 1) {
    const half = Math.floor(i / 2); // 중복 계산 방지
    dp[i] = p[i - 1]; // p의 i - 1번째 카드팩의 값을 할당

    for (let j = 1; j <= half; j += 1) {
        dp[i] = Math.max(dp[i], dp[j] + dp[i - j]) // 합하여 i를 만들 수 있는 인덱스들의 원소와 i번째 원소를 비교함
    }
}
console.log(dp[n]);
```