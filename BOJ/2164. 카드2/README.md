---
문제번호: 2164
문제이름: '카드2'
주소: 'https://www.acmicpc.net/problem/2164'
분류: ['자료구조', '큐']
---

# 풀이

문제의 분류는 큐로 되어 있는데, 다른 언어는 모르겠는데 C++에서는 STL을 사용해서 그냥 큐를 사용해서 풀면 풀린다. 그러나 자바스크립트에서 큐는 존재하지 않고 배열 메서드인 `push()`, `shift()`를 사용하면 당연하게 TLE로 터진다.

```js
let q = Array(n).fill(0).map((_, i) => (i + 1));

while (q.length > 1) {
    q.shift();
    q.push(q.shift());
}

console.log(q);
```

자바스크립트로 풀기 위해서 해결 방법을 고민해봤다. 먼저 맨 위 카드를 제거하는 것을 `삭제`라 하고 맨 뒤로 집어넣는 작업을 `추출`이라고 하겠다. 어떤 `n`이 입력으로 주어지든 1부터 시작하므로 `삭제`, `추출`, `삭제`, `...`, `마지막 작업` 형태로 진행된다. 만약 `n`이 짝수라면 마지막 작업이 `추출`로 끝날 것이고 `n`이 홀수라면 `삭제`로 끝날 것이다.

첫 순회에서는 `삭제`로 시작하기 때문에 짝수만 남게된다. 그리고 다음 순회에서는 이전 순회에서 어떤 작업으로 끝났는지가 중요하다. 이전 순회에서 만약 `삭제`로 작업이 끝났다면 이번 순회에서는 `추출`로 시작할 것이고 반대의 경우 `삭제`로 시작할 것이다. 이전 순회에서 어떤 작업으로 끝났는지 파악하여 다음 작업으로 넘겨주면 문제를 해결할 수 있다.

```js
function solution(n) {
    if (n === 1) return 1;
    let res = Array(n).fill(0).map((_, i) => i + 1);
    let temp = [];
    let deleteBegin = true;

    while (res.length > 1) {
        let i = deleteBegin ? 1 : 0;
        for (i; i < res.length; i += 2) {
            temp.push(res[i]);
        }
        deleteBegin = res.length % 2 === 0 ? deleteBegin : !deleteBegin;
        res = temp;
        temp = [];
    }
    return res[0];
}
```

나는 위 코드와 같이 문제해결을 했다. `n`이 1인 경우 1밖에 없으므로 바로 1을 반환한다.

1. 첫 순회는 `삭제`로 시작하므로 짝수만 `temp` 배열에 추출한다.
2. 이전 작업값의 길이가 홀수인지 짝수인지 파악한다. 홀수면 `삭제`, `...`, `삭제`로 끝나고 짝수면 `삭제`, `...`, `추출`로 끝나기 때문에 다음 순회에 어떤 작업으로 시작할 것인지 알린다.
3. `temp` 배열의 값을 `res` 배열에 담는다.
4. `res` 배열의 길이가 1이 될 때까지 반복한다.

## 규칙

문제를 풀면서 테스트 코드를 돌려봤는데 다음과 같은 규칙이 있었다.

| n  | 값  |
|:----:|:----:|
| $1$  | $1 = 2 * 1 - 2^0$  |
| $2$  | $2 = 2 * 2 - 2^1$  |
| $3$  | $2 = 2 * 3 - 2^2$  |
| $4$  | $4 = 2 * 4 - 2^2$  |
| $5$  | $2 = 2 * 5 - 2^3$  |
| $6$  | $4 = 2 * 6 - 2^3$  |
| $7$  | $6 = 2 * 7 - 2^3$  |
| $8$  | $8 = 2 * 8 - 2^3$  |
| $9$  | $2 = 2 * 9 - 2^4$  |
| $10$ | $4 = 2 * 10 - 2^4$ |
| $11$ | $6 = 2 * 11 - 2^4$ |
| $12$ | $8 = 2 * 12 - 2^4$ |
| $13$ | $10 = 2 * 13 - 2^4$ |

만약 `n`이 2의 거듭제곱이라면 그대로 반환하고 그렇지 않은 경우 $2 * n - x$이다. $x$는 `n`보다 크거나 같은 2의 거듭제곱이다.
TODO: n & -n 왜 2의 거듭제곱을 판별할 수 있는지 설명 추가하기. (2의 보수)

```js
function solution (n) {
    if ((n & -n) === n) return n; 
    let b = 1;
    while (b < n) b *= 2;
    return 2 * n - b;
}
console.log(solution(n));
```

코드로 나타내면 위와 같다.