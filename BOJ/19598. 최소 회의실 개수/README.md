---
문제번호: 19598
문제이름: '최소 회의실 개수'
주소: 'https://www.acmicpc.net/problem/19598'
분류: ['자료구조', '그리디 알고리즘', '정렬', '스위핑', '우선순위 큐']
---

# 첫 번째 풀이

문제를 보자마자 그림을 그려서 어떤 회의가 있는 구간내에 다른 회의가 있다면 카운트를 세어서 최댓값을 찾으면 되는 문제라 생각했다. 회의가 빨리 시작하는 순서대로 정렬을 하고 순회하면서 카운터의 증감을 주도록 아이디어를 잡긴했는데 어떻게 구현해야 할 지 감이 잘 안왔다.

먼저 주어진 값을 $[시작 시간, 1], [종료 시간, -1]$의 형태로 배열에 담는다. 시작 시간에 도달하면 어찌 되었든 회의가 1개 있다는 말이므로 카운터에 1을 더하고 종료 시간에 도달하면 시간한 회의가 종료하였으므로 카운터에서 1을 빼주기 위함이다.

이 때 회의가 빨리 시작한 순서로 정렬을 하는데 시작 시간과 종료 시간이 같은 경우에는 별개의 회의로 취급하므로 종료 시간인 경우가 더 앞으로 오게 정렬한다.

이후 정렬된 배열을 순회하면서 값의 증감에 따라 최댓값을 저장하여 반환하면된다.

```js
const [n, ...schedules] = require('fs')
    .readFileSync('./data.in')
    .toString()
    .trim()
    .split('\n');

/**
 * 이 부분이 아이디어의 핵심으로 직선상에 시작 시간과 종료 시간을
 * 나타내어 시작 할때 값을 증가하고 종료할 때 값을 감소시킬 수 있게된다.
 */
const sorted = schedules.flatMap(schedule => {
    const [begin, end] = schedule.split(' ').map(Number);
    return [[begin, 1], [end, -1]];
}).sort((a, b) => a[0] - b[0] || a[1] - b[1]);

let cnt = 0, mx = 0;
/**
 * 이후 값의 증감을 파악하고 카운터가 최대일 때의 값을 
 * 반환값으로 설정하면 된다.
 */
for (let i = 0; i < sorted.length; i += 1) {
    cnt += sorted[i][1];
    mx = Math.max(mx, cnt);
    console.log(mx, cnt);
}

console.log(mx);
```

# 두 번째 풀이

우선순위 큐